фоновая картинка
    &::before {
        content: "";
        position: absolute;
        inset: 0;
        background-image: url("/favicon.png");
        background-repeat: no-repeat;
        background-position: center;
        background-size: cover;
        filter: brightness(0.25);
        opacity: 0.8;
        z-index: 0;
        background-size: 190%;
    }
    > * {
        position: relative;
        z-index: 2;
    }

Див с картинкой
    {/* <div className="landingPics">
    <div className="picWrap">
        <img src={runner} alt="" />
        <div className="achieveDiv">
        <div className="achieveIcon">
            <img src={cup} alt="" />
        </div>
        <div className="landingSpans">
            <span className="achieveSpan">
                Ходит на фитнес
            </span>
            <span className="achieveInfo">
                Уже 3 месяца
            </span>
        </div>
    </div>
    </div>
</div> */}

Для почты
hvkk porj yhrx yyfw


scss уведомлений

@keyframes messageSlideIn {
    0% {
        transform: translateX(120%);
        opacity: 0;
    }
    100% {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes messageSlideOut {
    0% {
        transform: translateX(0);
        opacity: 1;
    }
    100% {
        transform: translateX(120%);
        opacity: 0;
    }
}

.message {
    position: fixed;
    right: 2vw;
    margin-top: 5vh;
    transform: translateX(120%);
    min-height: 9vh;
    min-width: 12vw;
    max-width: 15vw;
    border-radius: 12px;
    opacity: 0;
    z-index: 10;
    box-shadow: 0 4px 8px #00000033;
}

.messageActive {
    animation: messageSlideIn 0.5s ease forwards;
    
}
.messageHide {
    animation: messageSlideOut 0.5s ease forwards;
}

.messageUpdated {
    border: 2px solid #28a745;
    background-color: #d4edda;
}

.messageError {
    background-color: #f8d7da;
    border: 2px solid #dc3545;
}

#messHead {
    padding: 2%;
    padding-left: 4%;
    margin: 0;
    font-size: 18px;
}

#messBody {
    font-size: 16px;
    margin-left: 4%;
    margin-top: 2%;
}

.messHeadUpdated {
    color: #28a745;
    border-bottom: 2px solid #28a745;
}

.messBodyUpdated {
    color: #28a745;
}

.messHeadError {
    border-bottom: 2px solid #dc3545;
    color: #dc3545;
}

.messBodyError {
    color: #dc3545;
}


habits map
                                {habits.map((habit, idx) => (
                                    <div className="habit" key={idx}>
                                        <div className="habitInfo">
                                            <div>{habit.name}</div>
                                            <div className="habitPer">{ruperiodicity(habit)}</div>
                                        </div>
                                        <ChevronRight/>
                                    </div>
                                ))}
Значения chosen_days
    const dayMap: Record<string, string> = {
        Sun: "вс",
        Mon: "пн",
        Tue: "вт",
        Wed: "ср",
        Thu: "чт",
        Fri: "пт",
        Sat: "сб",
    }

Архив
{/* {habitsPast.length > 0 && (
    <div className="archieveWrapper">
        <div
            className="archieveButt"
            onClick={() => setShowArchieve(!showArchieve)}
        >
            Архив <ChevronDown style={{ rotate: showArchieve ? "180deg" : "" }} />
        </div>

        <div className={`archieveContent ${showArchieve ? "open" : ""}`}>
            {orderHabits?.map((order, idx) => {
                const filtered = filterHabitsByOrder(order, habitsPast)
                if (filtered.length === 0) return null
                return (
                    <div key={idx} className={`${order}OrderDiv orderDiv`}>
                        <div className="orderName">{order}</div>
                        {retHabits(filtered)}
                    </div>
                )
            })}
        </div>
    </div>
)} */}

// .archieveWrapper {
//     position: fixed;
//     width: 25vw;
//     height: 4vh;
//     background-color: $mc;
// }
// .archieveButt {
//     width: 100%;
//     display: flex;
//     flex-direction: row;
//     align-items: center;
//     justify-content: center;
//     font-size: 20px;
//     cursor: pointer;
//     padding: 1.5vh 0;
//     color: $borderWh;
//     > svg {
//         transition: rotate 0.3s ease;
//     }
//     &::before,
//     &::after {
//         content: "";
//         flex: 1;
//         border-bottom: 1px solid $borderWh;
//         margin: 0 0.4vw;
//     }
// }
// .archieveContent {
//     background-color: $mc;
//     border-radius: 0 0 12px 12px;
//     max-height: 0;
//     overflow: hidden;
//     transition: max-height 0.35s ease, opacity 0.35s ease;
//     opacity: 0;

//     &.open {
//         max-height: 500px; // ставим заведомо больше возможного контента
//         opacity: 1;
//     }
// }

    const years = Array.from({ length: 12 }, (_, i) => 2020 + i);

    <div className="habitsWrapperStats archieve" onClick={() => setShowList(prev => ({...prev, archieve:!prev.archieve}))}>
                        <div className="habitsOpen">
                            Архив
                            <ChevronDown />
                        </div>

                        {showList.ongoing && Object.entries(grouped).map(([order, list]) => (
                            <div key={order}>
                                <h4>{orderName(order)}</h4>
                                {list.map(h => {
                                    if (!h.ongoing) return (
                                        <HabitDiv key={h.id} habit={h} order={order} />
                                    )
                                })
                                } 
                            </div>
                        ))}
                    </div>


Данные в таблице меняються, одна привычка дублируеться в дргую было:
INSERT INTO "public"."habits" ("id", "user_id", "name", "start_date", "end_date", "ongoing", "periodicity", "chosen_days", "start_time", "end_time", "created_at", "pinned", "desc") VALUES ('19', '26', 'Готовлю новое блюдо', '2025-08-09', null, 'true', 'sometimes', null, null, null, '2025-08-14 15:45:01.000005+00', 'false', 'Эксперименты на кухне'), ('17', '26', 'Играю на гитаре', '2025-08-12', null, 'true', 'everyday', '[2, 4, 0]', '20:00', '20:40', '2025-08-14 15:45:01.000003+00', 'false', 'Разучивание песен'), ('18', '26', 'Изучаю фронтенд', '2025-08-06', null, 'true', 'everyday', '[1, 2, 3, 4, 5, 6, 0]', '10:00', '12:00', '2025-08-14 15:45:01.000004+00', 'false', 'React, TypeScript, SCSS'), ('14', '26', 'Пишу дневник', '2025-08-05', null, 'true', 'everyday', '[6]', '21:00', '21:30', '2025-08-14 15:45:01+00', 'false', 'Запись мыслей перед сном'), ('22', '26', 'Плаваю', '2025-08-08', null, 'true', 'weekly', '[1, 3]', '08:00', '09:00', '2025-08-14 15:45:01.000008+00', 'false', 'Бассейн'), ('16', '26', 'Прогаю', '2025-07-13', null, 'true', 'everyday', '[1, 4]', '00:00', '00:00', '2025-08-14 15:45:01.000002+00', 'true', 'Каждый божий день'), ('21', '26', 'Убираюсь дома', '2025-08-02', null, 'true', 'weekly', '[6]', '10:00', '12:00', '2025-08-14 15:45:01.000007+00', 'false', 'Генеральная уборка'), ('20', '26', 'Учусь английскому', '2025-08-07', null, 'true', 'everyday', '[1, 2, 3, 4, 5]', '07:00', '07:20', '2025-08-14 15:45:01.000006+00', 'true', 'Duolingo + книги'), ('12', '26', 'Хожу в зал', '2025-08-03', null, 'true', 'weekly', '[1, 3, 5]', '15:00', '19:00', '2025-08-14 15:37:14.724125+00', 'false', null), ('13', '26', 'Читаю', '2025-08-13', null, 'true', 'sometimes', null, null, null, '2025-08-14 15:37:49.474982+00', 'false', null);
Стало:
INSERT INTO "public"."habits" ("id", "user_id", "name", "start_date", "end_date", "ongoing", "periodicity", "chosen_days", "start_time", "end_time", "created_at", "pinned", "desc") VALUES ('19', '26', 'Готовлю новое блюдо', '2025-08-09', null, 'true', 'sometimes', null, null, null, '2025-08-14 15:45:01.000005+00', 'false', 'Эксперименты на кухне'), ('17', '26', 'Играю на гитаре', '2025-08-12', null, 'true', 'everyday', '[2, 4, 0]', '20:00', '20:40', '2025-08-14 15:45:01.000003+00', 'false', 'Разучивание песен'), ('22', '26', 'Изучаю фронтенд', '2025-08-06', null, 'true', 'everyday', '[1, 2, 3, 4, 5, 6, 0]', '10:00', '12:00', '2025-08-14 15:45:01.000008+00', 'false', 'React, TypeScript, SCSS'), ('14', '26', 'Пишу дневник', '2025-08-05', null, 'true', 'everyday', '[6]', '21:00', '21:30', '2025-08-14 15:45:01+00', 'false', 'Запись мыслей перед сном'), ('16', '26', 'Прогаю', '2025-07-13', null, 'true', 'everyday', '[1, 4]', '00:00', '00:00', '2025-08-14 15:45:01.000002+00', 'true', 'Каждый божий день'), ('21', '26', 'Убираюсь дома', '2025-08-02', null, 'true', 'weekly', '[6]', '10:00', '12:00', '2025-08-14 15:45:01.000007+00', 'false', 'Генеральная уборка'), ('18', '26', 'Учусь английскому', '2025-08-07', null, 'true', 'everyday', '[1, 2, 3, 4, 5]', '07:00', '07:20', '2025-08-14 15:45:01.000004+00', 'false', 'Duolingo + книги'), ('12', '26', 'Хожу в зал', '2025-08-03', null, 'true', 'weekly', '[1, 3, 5]', '15:00', '19:00', '2025-08-14 15:37:14.724125+00', 'false', ''), ('20', '26', 'Хожу в зал', '2025-08-03', null, 'true', 'weekly', '[1, 3, 5]', '15:00', '19:00', '2025-08-14 15:45:01.000006+00', 'true', ''), ('13', '26', 'Читаю', '2025-08-13', null, 'true', 'sometimes', null, null, null, '2025-08-14 15:37:49.474982+00', 'false', null);

Посмотри в чём проблема

export default function RedHabit({ habit }: RedHabitProps) {
    const {
        setNewName, setNewDescription, setNewStartDate, setNewEndDate,
        setNewOngoing, setNewPeriodicity, setNewDays, setNewStartTime,
        setNewEndTime, setPin, isUpdating
    } = useUpHabit();
    const navigate = useNavigate();

    const [name, setName] = useState(habit.name);
    const [desc, setDesc] = useState(habit.desc || "");
    const [startDate, setStartDate] = useState<Date | null>(habit.start_date ? new Date(habit.start_date) : null);
    const [endDate, setEndDate] = useState<Date | null>(habit.end_date ? new Date(habit.end_date) : null);
    const [ongoing, setOngoing] = useState(habit.ongoing);
    const [ pinned, setPinned ] = useState<boolean | undefined>()
    const [periodicity, setPeriodicity] = useState<string | number | undefined>(habit.periodicity);
    const [chosenDays, setChosenDays] = useState(
        [
            { value: 1, label: "Пн", chosen: habit.chosen_days?.includes(1) || false },
            { value: 2, label: "Вт", chosen: habit.chosen_days?.includes(2) || false },
            { value: 3, label: "Ср", chosen: habit.chosen_days?.includes(3) || false },
            { value: 4, label: "Чт", chosen: habit.chosen_days?.includes(4) || false },
            { value: 5, label: "Пт", chosen: habit.chosen_days?.includes(5) || false },
            { value: 6, label: "Сб", chosen: habit.chosen_days?.includes(6) || false },
            { value: 0, label: "Вс", chosen: habit.chosen_days?.includes(0) || false },
        ]
    );
    const [startTime, setStartTime] = useState(habit.start_time || "");
    const [endTime, setEndTime] = useState(habit.end_time || "");

    const periodicityArr = [
        { label: "каждый день", value: "everyday" },
        { label: "несколько дней в неделю", value: "weekly" },
        { label: "иногда", value: "sometimes" },
    ];

    const selectedPeriodicity = (per: string): number | undefined => {
        const index = periodicityArr.findIndex((p) => p.value === per);
        return index >= 0 ? index : undefined;
    };

    const formatTimeInput = (val: string) => {
        const digits = val.replace(/\D/g, "");
        if (digits.length >= 3) {
            let hh = digits.slice(0, 2);
            let mm = digits.slice(2, 4);
            if (parseInt(hh) > 23) hh = "23";
            if (parseInt(mm) > 59) mm = "59";
            return hh + ":" + mm;
        }
        return digits;
    };

    const toggleDay = (value: number) => {
        setChosenDays(chosenDays.map(day =>
            day.value === value ? { ...day, chosen: !day.chosen } : day
        ));
    };

    const clearChosenDays = () => {
        setChosenDays(chosenDays.map(d => ({ ...d, chosen: false })));
    };

    // Синхронизация с сервером
    
    useEffect(() => { setNewName(name)}, [name, setNewName]);
    useEffect(() => { setNewDescription(desc)}, [desc, setNewDescription]);
    useEffect(() => { if(startDate) setNewStartDate(startDate)}, [setNewStartDate, startDate]);
    useEffect(() => { setNewEndDate(endDate)}, [endDate, setNewEndDate]);
    useEffect(() => { setNewOngoing(ongoing)}, [ongoing, setNewOngoing]);
    useEffect(() => { setNewPeriodicity(periodicity)}, [periodicity, setNewPeriodicity]);
    useEffect(() => { setNewDays(chosenDays)}, [chosenDays, setNewDays]);
    useEffect(() => { setNewStartTime(startTime)}, [setNewStartTime, startTime]);
    useEffect(() => { setNewEndTime(endTime)}, [endTime, setNewEndTime]);
    useEffect(() => {if (habit) setPinned(habit?.pinned)}, [habit])

    return (
        <div className="redHabit">
            <div className="reviewHabit">
                <div className="selectedHabit" onClick={() => navigate("/stats")}>
                    <ChevronLeft />
                    {habit.name}
                </div>
                <div className="habitButts">
                    <span
                        className="spanSaveHabit"
                        style={{ display: isUpdating.length > 0 ? "block" : "none" }}
                    >
                        Сохранение...
                    </span>
                    <div onClick={() => setPin(!pinned)}>
                        {pinned ? <PinOff className="pinHabit" /> : <Pin className="pinHabit" />}
                    </div>
                    <div>
                        <Trash2 className="delHabit" />
                    </div>
                </div>
            </div>
            <div className="redHabitWrapper input">
                <input
                    type="text"
                    placeholder="Название"
                    maxLength={40}
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
                <span>{name.length}/40</span>
            </div>

            <div className="redHabitWrapper textarea">
                <textarea
                    placeholder="Описание (не обязательно)"
                    maxLength={120}
                    value={desc}
                    onChange={(e) => setDesc(e.currentTarget.value)}
                />
                <span>{desc.length}/120</span>
            </div>

            <div className="redHabitWrapper dates">
                <div className="redHabitWrapper inputs">
                    <CalendarInput
                        value={startDate}
                        onChange={setStartDate}
                        maxDate={new Date()}
                        placeholder={"С дд.мм.гггг"}
                    />
                    {ongoing ? (
                        <input type="text" readOnly value={"По настоящее время"} />
                    ) : (
                        <CalendarInput
                        value={endDate}
                        onChange={setEndDate}
                        maxDate={new Date()}
                        minDate={startDate || undefined}
                        placeholder={"По дд.мм.гггг"}
                        />
                    )}
                </div>
                <div className="formatCheckBox" onClick={() => setOngoing(!ongoing)}>
                    {ongoing ? (
                        <SquareCheck id="checkBoxPresent" color="#a8e63f" className="active"/>
                    ) : (
                        <Square id="checkBoxPresent" color="white"/>
                    )}
                    <label htmlFor="chekBoxPresent">по настоящее время</label>
                </div>
            </div>

            <div className="redHabitWrapper">
                <SelectList
                placeholder="Переодичность"
                className="redHabitSL"
                chevron={true}
                arr={periodicityArr}
                hide={true}
                prop={setPeriodicity as React.Dispatch<React.SetStateAction<string | number | undefined>>}
                readOnly={true}
                extraFunction={() => clearChosenDays()}
                selected={selectedPeriodicity(periodicity?.toString() || "")}
                />
            </div>

            {periodicity === "weekly" && (
                <div className="dayChanger">
                {chosenDays.map(({ value, label, chosen }) => (
                    <button
                    onClick={() => toggleDay(value)}
                    className={chosen ? "active" : ""}
                    key={value}
                    >
                    {label}
                    </button>
                ))}
                </div>
            )}

            <span className="spanTime">
                Время проведения <span>(необязательно)</span>
            </span>
            <div className="redHabitWrapper inputs">
                <input
                    type="text"
                    placeholder="чч:мм"
                    value={startTime}
                    onChange={(e) => setStartTime(formatTimeInput(e.target.value))}
                />
                -
                <input
                    type="text"
                    placeholder="чч:мм"
                    value={endTime}
                    onChange={(e) => setEndTime(formatTimeInput(e.target.value))}
                />
            </div>
        </div>
    );
}

import { useEffect, useState, createContext, useCallback, type ReactNode } from "react";
import axios from "axios";
import { useHabits } from "../hooks/HabitsHook";
import { useNote } from "../hooks/NoteHook";

export type UpdateHabitContextType = {
  setNewName: (val: string) => void;
  setNewDescription: (val: string) => void;
  setNewStartDate: (val: Date) => void;
  setNewEndDate: (val: Date | null) => void;
  setNewOngoing: (val: boolean) => void;
  setNewPeriodicity: (val: string | number | undefined) => void;
  setNewDays: (val: { value: number; label: string; chosen: boolean }[]) => void;
  setNewStartTime: (val: string | null) => void;
  setNewEndTime: (val: string | null) => void;
  setPin: (val: boolean) => void;
  setHabitId: (val: number) => void;
  isUpdating: string[];
};

type UpdateQueueItem = {
  habitId: number;
  field: string;
  value: string | number[] | boolean | Date | null;
};

const UpdateHabitContext = createContext<UpdateHabitContextType | null>(null);

export const UpdateHabitProvider = ({ children }: { children: ReactNode }) => {
  const { habits, refetchHabits } = useHabits();
  const { showNotification } = useNote();
  const [updateQueue, setUpdateQueue] = useState<UpdateQueueItem[]>([]);
  const [isUpdating, setIsUpdating] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [habitId, setHabitId] = useState<number | undefined>();

  // Стабилизируем функции setNew* с правильными зависимостями
  const setNewName = useCallback(
    (val: string) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "name" || item.habitId !== habitId),
          { habitId, field: "name", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewDescription = useCallback(
    (val: string) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "desc" || item.habitId !== habitId),
          { habitId, field: "desc", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewStartDate = useCallback(
    (val: Date) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "start_date" || item.habitId !== habitId),
          { habitId, field: "start_date", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewEndDate = useCallback(
    (val: Date | null) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "end_date" || item.habitId !== habitId),
          { habitId, field: "end_date", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewOngoing = useCallback(
    (val: boolean) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "ongoing" || item.habitId !== habitId),
          { habitId, field: "ongoing", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewPeriodicity = useCallback(
    (val: string | number | undefined) => {
      if (habitId && typeof val === "string") {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "periodicity" || item.habitId !== habitId),
          { habitId, field: "periodicity", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewDays = useCallback(
    (days: { value: number; label: string; chosen: boolean }[]) => {
      if (habitId) {
        const val = days.filter(d => d.chosen).map(d => d.value)
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "chosen_days" || item.habitId !== habitId),
          { habitId, field: "chosen_days", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewStartTime = useCallback(
    (val: string | null) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "start_time" || item.habitId !== habitId),
          { habitId, field: "start_time", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setNewEndTime = useCallback(
    (val: string | null) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "end_time" || item.habitId !== habitId),
          { habitId, field: "end_time", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const setPin = useCallback(
    (val: boolean) => {
      if (habitId) {
        setUpdateQueue((prev) => [
          ...prev.filter((item) => item.field !== "pinned" || item.habitId !== habitId),
          { habitId, field: "pinned", value: val },
        ]);
        setIsUpdating((prev) => [...new Set([...prev, `habit_${habitId}`])]);
      }
    },
    [habitId]
  );

  const processQueue = useCallback(async () => {
    if (isProcessing || updateQueue.length === 0) return;
    setIsProcessing(true);

    const { habitId, field, value } = updateQueue[0];
    const selectedHabit = habits?.find((h) => h.id === habitId);

    // Проверка, изменились ли данные
    if (
      (field === "name" && value === selectedHabit?.name) ||
      (field === "desc" && value === selectedHabit?.desc) ||
      (field === "start_date" &&
        value instanceof Date &&
        selectedHabit?.start_date &&
        value.getTime() === new Date(selectedHabit.start_date).getTime()) ||
      (field === "end_date" &&
        ((value === null && selectedHabit?.end_date === null) ||
          (value instanceof Date &&
            selectedHabit?.end_date &&
            value.getTime() === new Date(selectedHabit.end_date).getTime()))) ||
      (field === "ongoing" && value === selectedHabit?.ongoing) ||
      (field === "periodicity" && value === selectedHabit?.periodicity) ||
      (field === "chosen_days" && JSON.stringify(value) === JSON.stringify(selectedHabit?.chosen_days)) ||
      (field === "start_time" && value === selectedHabit?.start_time) ||
      (field === "end_time" && value === selectedHabit?.end_time) ||
      (field === "pinned" && value === selectedHabit?.pinned)
    ) {
      setUpdateQueue((prev) => prev.slice(1));
      setIsUpdating((prev) => prev.filter((item) => item !== `habit_${habitId}`));
      setIsProcessing(false);
      return;
    }

    const payload = {
      habit_id: habitId,
      [field]: value instanceof Date ? value.toISOString() : value,
    };

    try {
      const res = await axios.post("http://localhost:3001/updatehabit", payload, {
        withCredentials: true,
      });
      if (res.data.success) {
        console.log("✅ Успешно обновлено:", field);
        await refetchHabits(); // Ждём завершения refetchHabits
        showNotification("success", field === "pinned" ? (value ? "Закреплено" : "Откреплено") : "Привычка обновлена");
      } else {
        showNotification("error", res.data.error || "Ошибка при обновлении привычки");
      }
    } catch (err) {
      let errorMessage = "Ошибка при обновлении привычки";
      if (axios.isAxiosError(err) && err.response?.data?.error) {
        errorMessage = err.response.data.error;
      }
      showNotification("error", errorMessage);
      console.error("❌ Ошибка при обновлении привычки:", err);
    } finally {
      setUpdateQueue((prev) => prev.slice(1));
      setIsUpdating((prev) => prev.filter((item) => item !== `habit_${habitId}`));
      setIsProcessing(false);
    }
  }, [isProcessing, updateQueue, habits, refetchHabits, showNotification]);

  // Изменяем useEffect для предотвращения бесконечного цикла
  useEffect(() => {
    if (updateQueue.length === 0 || isProcessing) return;

    const handler = setTimeout(() => {
      processQueue();
    }, 200);

    return () => clearTimeout(handler);
  }, [updateQueue, isProcessing, processQueue]);

  return (
    <UpdateHabitContext.Provider
      value={{
        setNewName,
        setNewDescription,
        setNewStartDate,
        setNewEndDate,
        setNewOngoing,
        setNewPeriodicity,
        setNewDays,
        setNewStartTime,
        setNewEndTime,
        setPin,
        setHabitId,
        isUpdating,
      }}
    >
      {children}
    </UpdateHabitContext.Provider>
  );
};

export default UpdateHabitContext;

            <div className="addHabitWrapper input">
                <label htmlFor="nameInput">Название</label>
                <input type="text" id="nameInput" onChange={(e) => setName(e.target.value)} maxLength={40}/>
                <span>{name?.length}/40</span>
            </div>
            <div className="addHabitWrapper textarea">
                <textarea onChange={(e) => setDescription(e.currentTarget.value)} placeholder="Описание (не обязательно)" maxLength={120}>
                    {description}
                </textarea>
                <span>{description.length}/120</span>
            </div>
            <div className="addHabitWrapper dates">
                <div className="addHabitWrapper inputs">
                    <CalendarInput
                        value={startDate}
                        onChange={handleStartDateChange}
                        maxDate={new Date()}
                        minDate={undefined}
                        placeholder={"С дд.мм.гггг"}
                    />
                    {checkedPresent ? (
                        <input type="text" readOnly value={"По настоящее время"}/>
                    ) : (<CalendarInput
                        value={endDate}
                        onChange={handleEndDateChange}
                        maxDate={new Date()}
                        minDate={startDate || undefined}
                        placeholder={"По дд.мм.гггг"}
                    />)}
                </div>
                <div className="formatCheckBox" onClick={() => setCheckedPresent(!checkedPresent)}>
                    {checkedPresent ? (
                        <SquareCheck id="checkBoxPresent" color="#a8e63f" className="active"/>
                    ) : (
                        <Square id="checkBoxPresent" color="white"/>
                    )}
                    <label htmlFor="chekBoxPresent">
                        по настоящее время
                    </label>
                </div>
            </div>
            
            <div className="inpWrapperAddHabit">
                <SelectList placeholder="Переодичность" className="addHabitSL" chevron={true} arr={periodicityArr} hide={true} prop={setSelectedperiodicity} readOnly={true} extraFunction={clearInputPer} selected={undefined}/>
            </div>
            {selectedperiodicity === "weekly" && (
                <div className="dayChanger">
                    {chosenDays.map(({value, label, chosen}) => (
                        <button onClick={() => toggleDay(value)} className={`${chosen ? "active" :""}`} key={value}>{label}</button>
                    ))}
                </div>
            )}
            <span className="spanTime">Время проведения <span>(необязательно)</span></span>
            <div className="addHabitWrapper inputs">
                <input
                    type="text"
                    placeholder="чч:мм"
                    value={startTime}
                    onChange={(e) => {
                        const formatted = formatTimeInput(e.target.value);
                        if (formatted.length <= 5) {
                            setStartTime(formatted);
                        }
                    }}
                />
                -
                <input
                    type="text"
                    placeholder="чч:мм"
                    value={endTime}
                    onChange={(e) => {
                        const formatted = formatTimeInput(e.target.value);
                        if (formatted.length <= 5) {
                            setEndTime(formatted);
                        }
                    }}
                />
            </div>
            <button onClick={fetchAddHabit}>Сохранить</button>


.addHabitSL {
    @include selectList(100%, 4vh, 9%, 0.3vw, 0.8vh, $borderWh, $tc, $bgc, 18px, 1vh, 1vw, 10%);
    margin-bottom: 2vh;
    >input {
        @include input($mc, $tc, $borderWh, 4vh, 6px, $tc);
        width: 22vw;
        cursor: pointer;
    }
}
.addHabitWrapper {
    width: 22vw;
    position: relative;
    align-items: center;
    display: flex;
    flex-direction: column;
}
.addHabitWrapper.dates {
    flex-direction: column;
}
.addHabitWrapper.inputs {
    margin-bottom: 1vh;
    justify-content: space-between;
    > input {
        @include input($mc, $tc, $borderWh, 4vh, 6px, $tc);
        width: 10.5vw;
        padding-inline-start: 0.5vh;
    }
    >.react-datepicker-wrapper {
        position: relative;
        >.react-datepicker__input-container {
            display: block;
            >input {
                @include input($mc, $tc, $borderWh, 4vh, 6px, $tc);
                width: 10.5vw;
                margin-right: 1vw;
                padding-inline-start: 0.5vh;
            }
        }
        
    }
}
.addHabitWrapper.textarea {
    margin-bottom: 2vh;
    > textarea {
        padding: 0.5vh 0.2vw;
        width: 100%;
        height: 4rem;
        overflow-y: hidden;
        resize: none;
        font-family: $font;
        outline: none;
        font-size: 16px;
        border: 1px solid $borderWh;
        background-color: $mc;
        color: $tc;
        border-radius: 6px;
        padding-inline-start: 0.5vh;
        &:focus-visible {
            border: 1px solid $tc;
        }
    }
    >span {
        position: absolute;
        right: 0.5vw;
        bottom: 0.5vh;
        font-size: 16px;
        color: $borderWh;
    }
}
.addHabitWrapper.input {
    >input {
        @include input($mc, $tc, $tr, 4vh, 8px, $tr);
        margin-bottom: 2vh;
        width:100%;
        padding-right: 3vw;
        padding-inline-start: 0.5vh;
    }
    >span {
        position: absolute;
        right: 0.5vw;
        bottom: 3vh;
        font-size: 16px;
        color: $borderWh;
    }
}
.spanTime {
    font-size: 20px;
    margin-bottom: 1vh;
    > span {
        color: $borderHabit;
    }
}
.formatCheckBox {
    font-size: 18px;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    margin-bottom: 2vh;
    >svg {
        width: 20px;
        aspect-ratio: 1/1;
    }
    &:hover svg.active {
        filter: drop-shadow(0 0 5px #1bac1b);
    }
    &:hover svg {
        filter: drop-shadow(0 0 5px #fff);
    }
}

.dayChanger {
    position: relative;
    width: 20vw;
    display: flex;
    flex-direction: row;
    height: 5vh;
    margin-bottom: 2vh;
    >button {
        flex: 1;
        border-radius: 6px;
        outline: none;
        border: 1px solid black;
        background-color: $bgc;
        color: $borderWh;
        &:hover {
            background-color: $menuButtHover;
            color: $tc;
        }
    }
    >button.active {
        background-color: darken($borderWh, 40%);
        color: $tc;
        &:hover {
            background-color: darken($borderWh, 20%);
            color: $tc;
        }
    } 
}